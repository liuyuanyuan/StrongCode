# CPU 核数与时间片、多线程并行和并发

[TOC]



### CPU物理核数、逻辑核数

- **CPU个数**：即CPU芯片个数（物理上真实存在的）；
- **CPU物理核心数**（ Number Of Physical Cores）：是物理上的，也是硬件上实际的核心数；
- **CPU逻辑核心数**（Number Of Logical Processors）：是逻辑上的，是OS实际用于计算的核心数，可简单理解为逻辑上可以模拟出的核心数。（比如：1个物理核心可以模拟出2个逻辑核心）

**例子：**“2路4核2线程”

即为：2个CPU机，一个CPU机有4个核心单元（物理上），每个物理核心可以模拟出2个逻辑核心，即保证OS上2个线程并行运算（这是逻辑概念，即超线程技术，它可以实现单个物理核实现线程级别的并行计算。也就是说：OS会认为一个线程也是一个内核，当然这是OS的“错觉”）；

因此：该设备有2个CPU，8个物理核心，16个逻辑核心，最多并行16个线程。



### 多线程的并行、并发

- **并发：**当有多个线程在操作时，如果系统只有一个CPU核心，把CPU核心运行时间划分成若干个时间片，分配给各个线程（按一定的优先级）轮流执行；在任何一个确定时刻一个cpu核心只执行一个线程中的指令，当一个线程的代码运行时其它线程处于挂起状态。这种方式我们称之为**并发(Concurrent)**。**并发=间隔发生**。

- **并行：**当系统有一个以上CPU核心时，则线程的操作有可能非并发。当一个CPU核心执行一个线程时，另一个CPU核心可以执行另一个线程，两个线程互不抢占CPU资源，可以同时进行，这种方式我们称之为**并行(Parallel)**。 **并行=同时进行**。

**区别**：

并行是指两个或多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔内发生。

并行是同时做多件事情；并发表示同时发生了多件事情，通过时间片切换，哪怕只有单一的核心，也可以实现“同时做多件事情”这个效果。

根据底层CPU物理核数与线程的数量，并发与并行并不是两个互斥的概念。比如：当CPU逻辑核数为8，同时操作10个线程，那么：这10个线程是并发的，其中有8个线程可以并行。

并发可以是虚拟的同时执行，也可以是真的同时执行。而并行的意思是真的同时执行。

结论是：并行是我们物理时空下的同时执行，而并发则是操作系统用线程这个模型抽象之后站在线程的视角上看到的“同时”执行。



### CPU逻辑核数、时间片与多线程并行、并发

**最大并行线程数**：一个物理机在同一时刻并行执行的最大线程个数，等于CPU逻辑核数。

**当线程数<=CPU逻辑核数**，可以给每个线程分配一个逻辑核心，这些线程是并行的。

**当线程数>CPU逻辑核数**，逻辑核数不够分给所有线程，所以将CPU运行时间划分成若干个时间片，分配给各个线程执行，在一个时间段的线程代码运行时，其它线程处于挂起状态。多线程的时间片的上下文切换，会产生额外的时间消耗，因此并不是线程越多效率越高。



## 根据CPU核数确定线程池并发数

参考：[根据CPU核数确定线程池并发数](https://www.cnblogs.com/dennyzhangdd/p/6909771.html)

- 在《Java Concurrency in Practice》一书中，给出了估算线程池大小的公式：

$$
Nthreads=Ncpu*Ucpu*(1+w/c)
$$

​		其中：Ncpu=cpu逻辑核心数；
​				   Ucpu=cpu使用率，0~1；
​				   W/C=等待时间与计算时间的比率；

- 在《Programming Concurrency on the JVM Mastering》一书中，

$$
线程数=Ncpu/（1-阻塞系数）
$$



**那么实际使用中并发线程数如何设置呢？**

我们以派系一公式为例，分析如下：
$$
Nthreads=Ncpu*(1+w/c)
$$
**IO密集型：**一般情况下，如果存在IO，那么肯定w/c>1（阻塞耗时一般都是计算耗时的很多倍）,但是需要考虑系统内存有限（每开启一个线程都需要内存空间），这里需要上服务器测试具体多少个线程数适合（CPU占比、线程数、总耗时、内存消耗）。如果不想去测试，保守点取1即，Nthreads=Ncpu*(1+1)=2Ncpu。这样设置一般都OK。

**计算密集型**：假设没有等待w=0，则W/C=0. Nthreads=Ncpu。



**至此结论：**

**IO密集型=2Ncpu**（可以测试后自己控制大小，2Ncpu一般没问题）（常出现于线程中：数据库数据交互、文件上传下载、网络数据传输等等）

**计算密集型=Ncpu**（常出现于线程中：复杂算法）

**java中：Ncpu=`Runtime.getRuntime().availableProcessors()`**



